### 무엇이 좋은 알고리즘인가?

```
1. 정확성 : 얼마나 정확하게 동작하는가
2. 작업량 : 얼마나 적은 연산으로 원하는 결과를 얻어내는가.
3. 메모리 사용량 : 얼마나 적은 메모리를 사용하는가.
4. 단순성 : 얼마나 단순한가.
5. 최적성 : 더 이상 개선할 여지없이 최적화 되었는가.
```

#### 빅-오(O) 표기법

```
시간 복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시한다.
계수는 생략하여 표시한다.
```

```
입력값이 상수일때는 대표값 O(0)을 쓴다.

버블정렬, 선택정렬, 삽입 정렬 : O(n^2)

카운팅 정렬 : O(n+k) - 속도는 빠르지만 항상 쓸 수 있는게 아니다. 적용할 수 있는 경우가 제한적.

퀵 정렬, 병합정렬 : O(n logn)
```



# 자료구조

자료를 열거하는 방법



### 버블정렬(Bubble Sort)

나에게 주어진 인덱스 범위를 확인

2개씩 비교 할 때의 기준이 필요하다.



- 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식
- 정렬 과정
  - 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동한다.
  - 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬된다.
    - 배열의 크기가 N일 때 인덱스는 0부터 N-1 까지
    - 크기 비교를 N-1번 반복한다.
    - 두 개의 요소 중 앞의 것을 안다면 i, i+1을 비교 뒤의 것을 안다면 i-1, i를 비교
    - 둘 중 하나의 위치만 알면 된다.
    - 앞에서 부터 비교한다면 i는 0부터 N-2까지 가야한다.
      - i+1까지 비교해야 하므로 인덱스 에러를 방지하기 위함.

```python
def BubbleSort(a, N) # 정렬할 List, N 원소 수
	for i in range(N-1, 0, -1) # i의 범위 -> list의 맨 뒤 -1 인덱스에서부터 0까지. 맨 뒷자리는 비교할 필요가 없기 때문.
    	for j in range(0, i)
        	if a[j] > a[j+1] # a[j]가 a[j+1]보다 크다면 서로 자리를 교환한다.
            	a[j], a[j+1] = a[j+1], a[j]
# a[j], a[j-1] 비교
def BubbleSort(a, N):
    for i in range(N-1, 0, -1):
        for j in range(1, i+1):
            if a[j] < a[j - 1]:
                a[j -1], a[j] = a[j], a[j-1]
```



## 카운팅 정렬

1. 숫자의 개수를 세는 과정
2. 숫자의 개수를 센 것을 누적하는 과정
3. data의 역순으로 재정렬 하는 과정

항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘

- 단 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능하다. 각 항목의 발생횟수를 기록하기 위해 정수항목으로 인덱스되는 배열을 사용하기 때문이다.
- 또한 카운트들을 할당하기 위한 충분한 공간을 만들기 위해 조건 집합 내의 가장 큰 정수를 알아야 한다.
  - 즉, COUNTS를 저장하는 Test case는 원래의 조건만큼 만들어 놓아야 한다.
  -  `0~100 이하의 정수 100개가 주어진다.` 는 조건이 있고 주어진 값이 0~4라면 Test case는 100개를 만든다.

리스트에 있어 가장 중요한것은 인덱스.

if, for, while 그리고 인덱싱으로 문제를 해결하자.

```python
def Counting_Sort(A, K) 
# A [] -- 입력 배열(1 to k) k = 최댓값
# B [] -- 정렬된 배열.
# C [] -- 카운트 배열.

	C = [0] * (k+1) #최댓값 +1. 0~k까지의 인덱스를 만들어야 하기 때문
    B = [0] * len(A) # 입력할 data 길이만큼
    for i in range (0, len(A)):
        C[A[i]] += 1
        
    for i in range (1, len(C)):
        C[i] += C[i-1]
        
    for i in range (len(B)-1, -1, -1):
        C[A[i]] -= 1
        B[C[A[i]]] = A[i]
```





# List 01

### 1차 배열(파이썬에서 List)에 저장된 자료들을 조작

- 전체 자료들 순회/역방향 순회
  - 정수들의 총합
- 최대값/최소값 찾기
  - 위치(인덱스) 찾기
  - 최대/최소값이 여러개인 경우
- 거품 정렬 / 카운팅 정렬



### 알고리즘 설계 기법

문제를 풀 때 막연하게 하는게 아닌 체계적으로 풀기 위한 기법들.

- 완전탐색(Exaustive Search) - 가장 기본적인 접근 방법
- 탐욕(Greedy) 메소드
- 분할 정복(Divide and Quanqer)
- 백트래킹(Backtracking)
- 동적 계획법(Dynamic Programing, DP)